Stappen plan angular2 training:
    - Zoals tour of hero's alles beginnen in 1 app.component
    - maak een simpele list met de bestaande angular directives
    - maak een simpele detail van een selected uit de list
    - verplaats de detail naar een aparte component
    - verplaats de list naar een aparte component
    - maak een service die statische data retourneert
    - maak een eigen feature component/module
    - verplaats de shit naar die feature component module
    - maak een derde 'dashboard' component en module
    - gebruik de service ook in het dashboard gedeelte
    - rout vanaf het dashboard naar de movies toe
    - maak een echte http call vanuit de service met promises en observables.

oefeningen opzet:
- npm install -g angular-cli
- npm install -g typescript

oefening
- ng new movie-assigments --style=scss
- npm start

oefeningen
- in app-component:
- return een array met movieobjecten
- in de view (html) ng-for loop om de movies te tonen

oefening 
- maak een folder movies en zet daarin een movie model class, waarin je typed movie properties definieerd
- maak de movies item in de app-component typed mbv van deze model class (new movie.ts, import movies/movie.ts)

oefening
- zet een click event property op een movie item die een functie in de component aanroept
- in de html toon de geselecteerde movie (selectedMovie), gebruik ng-if

oefening
- maak een nieuwe stateless component in movies folder: movie-detail.component
- maak een input property movie van type movie

oefening 
- in app module registreer new component bij declarations
- vervang de selectedmovie html door de nieuwe selector <movie-detail> en geef de selectedMovie als input mee aan deze movie-detail component
///- zet een functie op de output propery van movie-detail

oefening
- verplaats movie-list functionaliteit van app-component naar nieuw movies-list component in de map movies
- maak een input property movies, die wordt gevuld door de movies array in app-component
- maak een output propery movieClicked van type eventEmitter(); (belangrijk moet geinstatieerd worden met new)
- in movie-list.html plaats een event propery die de click afvangt met movie als event object. 
- In de movie-list.component emit de clicked movie event in de onMovieClicked functie die zelf gemaakt moet worden

oefening 
- in app.module kijk of de movie-list component bij de declarations staat
- vervang de huidige statische list in de app.component.html door de <movies-list> selector en geef als input de movies array

oefening 
- in app component maak een functie die het event object van movie list afvangt (emitted movie) en de selectedMovie set.
- en zet de movieClicked event binding op <movies-list> in app.component.html die deze functie met als parameter de geselecteerde movie zal gaan uitvoeren.
- zorg dat de selected movie weer getoond wordt.

oefening 
het ophalen van data doe je normaliter niet een component, maar in een service. Een service wordt binnen Angular maar 1x geinstatieerd waardoor het een singleton is en je eventueel nog data kan cachen.
Een service is dan ook ideaal om data op te halen en te bewerken.
- verplaats de movielijst naar een nieuwe movie service. maak deze service in de root van de map movies.
- zorg ervoor de service module/app breed beschikbaar is via een import en een toevoeging aan de providers array
- maak in app.component.ts gebruik van deze nieuwe service middels de constructor

oefening 
We hebben nu een movielist, detail en service die allemaal onder de 'feature' movies vallen. deze kunnen en moeten eigenlijk op zichzelf kunnen staan en werken zonder afhankelijk te zijn van de app die we nu aan het maken zijn.
- Maak een movies.module aan en maak een nieuwe ngmodule. via ng g module movies
- na het uitvoeren van dit commando heb je een movies.module en een movies.component. Dit component wordt de root-component van deze nieuwe module.
- De movies.component gaat de functionaliteit overnemen die nu in de app.component wordt gedaan.
- import & declareer de movies.component in de nieuwe movies.module en verplaats de imports en declarations van de movie-list component, movie-detail component en movie.service die in app.module staan naar deze module.
- deze module willen we gebruiken in onze app.component, daarvoor moeten we de root-component (movies.component) exporteren in movies.module.
- exporteer de root-component in de movies.module en importeer deze nieuwe module in de app module en voeg hem toe aan de angular imports array
- zorg ervoor de app weer werkt door de movies.component te gebruiken in de app.component.html
- tip: krijg je een error dat ngIf en ngFor niet herkent wordt? Zorg ervoor dat in movies.module wel de @angular/common module wordt geimporteerd en in de angular imports array staat.

oefening 9:
De app werkt weer, maar zou het niet mooi zijn als we de movies module konden bereiken via een eigen unieke url?
Hiervoor moeten we een link/route/url naar de movies.component maken.
We zorgen er eerst voor dat movies standaard getoond wordt door een redirect te registreren als er naar de root url wordt genavigeerd.
- om de angular router te vertellen hoe url's opgebouwd moeten worden is het nodig om een base href in de index.html te plaatsen : <base href="/">
- importeer de routermodule en routes uit angular/router in de app.module.
- Voeg een route toe aan de app module imports door gebruik te maken van de RouterModule.forRoot functie met de config: path '', redirectTo: 'movies', pathMatch: 'full'.
- importeer de routermodule en routes uit angular/router ook in de movies.module.
- Voeg een route toe aan de movies module imports door gebruik te maken van de RouterModule.forChild functie met de config: path 'movies' en component: MoviesComponent.
- omdat de movies.component nu benaderd gaat worden via een url, haal de selector property van dit component weg
- nu moeten we angular nog vertellen waar hij components op basis van een url moet neerzetten. Dit doen we door in app.component.ts de selector <router-outlet> te plaatsen. NB: de oude selector van movies.component hier ook weghalen
- nu de we movies module benaderen via een url hoeft de movies.component ook niet meer geexporteerd te worden in de movies.module. Hij heeft immers geen selector meer.

oefening 9.1:
Beter om in eigen file maken/separation of concerns
- maak een nieuw bestand op hetzelfde niveau als de app.component en noem het app-routing.module.ts
- maak een nieuwe constante en typeer deze als 'Routes'. stop daar de route configuratie in.
- maak een ngModule in het bestand die de forRoot angular import doet van de routes en geef de routermodule ook op in de exports array. (Wat je hier eigenlijk doet is routermodule importeren, er wat aan toe voegen (config) via de forroot functie en weer exporteren.)
- importeer de nieuwe module in de app.module en voeg hem toe aan de module imports array (als laatste!)
- doe hetzelfde voor de movies module. Maar hier een movies.routing.modules.ts bestand.

oefening ..:
- maak een derde module 'dashboard' aan met angular cli : ng g module --routing
- geef de dashbaord.component de route path 'dashboard'
- Haal in de dashboard component een lijst op van alleen je favoriete movies, gebruik hiervoor de movie service, en toon de lijst.


oefening ...:
- Voeg bovenin een button toe in de template van de dashboard component. Voeg op de button een link toe naar de movies component door de angular routerLink directive te gebruiken.

oefening ...:
- Voeg bovenin een button toe in de template van de movies component. Voeg op de button een link toe naar de dashboard component door de angular routerLink directive te gebruiken.

oefening ...:
De vorige twee oefeningen zijn een beetje dubbelop. We willen kunnen navigeren zonder iedere keer de knoppen naar andere pagina's te moeten toevoegen op iedere pagina.
- Voeg  


oefening 10.0 http - configuratie
- NB: onderstaand stappenplan gebaseerd op: https://angular.io/docs/ts/latest/tutorial/toh-pt6.html
- HTTP services registereren. Om een http backend call te doen moeten @angular/htpp importeren. Deze services willen we overal kunnen gebruiken, dus is het raadzaam om dit in de AppModule te doen.
- in app.module.ts import HttpModule from @angular/http
- we hebben nog geen echte backend api waar we met een http call tegen aan kunnen praten. Tot die tijd gaan we de backend mocken waarvoor Angular 2 een toolset voor heeft, nl de in-memory web api
- deze moeten we nog installeren, dus voer uit: npm install angular-in-memory-web-api --save-dev
- in app.module.ts voeg de volgende imports toe:
    // Imports for loading & configuring the in-memory web api
    import { InMemoryWebApiModule } from 'angular-in-memory-web-api';
    import { InMemoryDataService }  from './in-memory-data.service';
- in app.module.ts voeg het volgende toe aan de @NgModule imports array:
    - InMemoryWebApiModule.forRoot(InMemoryDataService)
- Deze InMemoryWebApiModule vervangt de default Http client
- maak een in-memory-data.service.ts file aan en plaats hier een InMemoryDataService class welke de interface InMemoryDBService implementeert
- maak in deze class gebruik van de createDb functie die de lijst van films gaat retourneren

Oefening 10.1 http - de async backend call!
- in de movie.service gaan we nu een echte backend call implementeren
- import de Http module
- injecteer de Http service in de movieService contructor
- maak een private property moviesUrl met als value 'api/movies' en een private propery moviesFavUrl met als value 'api/moviesFav
- verander de getMovies en getFavMovies functies zodanig dat deze een http call doet naar de juiste url en een promise retourneert met als payload een array van het type Movie
    - roep direct de 'toPromise' functie aan op het resultaat van de get functie.   // Converteer het synchrone resultaat (observable) van de get functie naar een promise.
    - om de toPromise functie te kunnen gebruiken importeer de rxjs operator toPromise: import 'rxjs/add/operator/toPromise';
	- Roep de then functie aan op het resultaat van de 'toPromise' en geef een arrow functie als als asynchrone callback mee.
	- De arrow functie krijgt 1 parameter van het type Response. roep de functie json() aan op deze parameter en laat de error functie dit als resultaat retourneren.
	- geef uiteindelijk het synchrone resultaat van de then functie terug als resultaat van de getMovies.
- verander in movies.component.ts en in dashboard.component.ts de ngOnInit functies zodanig dat deze gebruik gaan maken van de promises die de movieservice nu zal retourneren.

Oefening .. - de core module
links: https://angular.io/docs/ts/latest/guide/style-guide.html#!#04-11
Uitleg: een core module is de plek om app brede services en single-use components in op te slaan. Hierin staat alleen componenten die op een vaste plek staan in app.component.nl. Denk bijv aan een navigatie component en in het geval van services aan een loggerService
- maak een nieuwe core module via ng g module core
- verwijder het aangemaakte core.component en verwijder hem ook uit de core.module
- maak een nieuw navigatie component via ng g component core/navigatie
- knip de html uit app.component.html betreffende de navigatie, de <nav> node en plak deze in de html template van de nieuwe core/nav component.
- voeg het nieuwe nav component toe aan de declarations en exports array van de core module.
- importeer de core module in de app module en pas het nieuwe nav component toe in app.component.html
- je zult zien dat de routerlinks niet meer werken, dit komt omdat de routerModule nog niet door de core module wordt geimporteerd. Importeer daarom de routerModule en voeg deze toe aan de imports array van de core module.

Oefening .. - de routerLinkActive directive
Uitleg: the routerLinkActive directive kun je gebruiken om een css class toe te voegen aan het element wanneer zijn route gelijk is aan de active route
- in de core/nav component voeg de routerLinkActive directive toe op beide navigatie links, geef als css class 'active' mee. ie: routerLinkActive="active"
- voeg de active class toe aan de stylesheet van de core/nav component en geef het active menu-item bijvoorbeeld een andere kleur of een underline 

oefening ..: 
uitleg:een shared module bevat components die overal in de applicatie hergebruikt worden. De shared module zal over het algemeen geen services providen, omdat deze niet singleton zullen zijn.
- genereer een shared module met het commando 'ng g module shared'
- verwijder de shared component files
- genereer een herbruikbaar loading-bar component 'ng g component shared/loading-bar/loading-bar'
- geneer een service die we alleen in de loading bar gaan gebruiken 'ng g service shared/loading-bar/loading-bar/loading-bar'
- importeer de service in het component.
  - voeg de service toe aan de providers array van het component//ieder instantie van de component zal een eigen instantie van de service hebben (component scoped)
  - injecteer de service in de component class
- 


oefening ..:
- aparte oefening voor uitleg over observables ?

oefeningen user input:
oefening...:
- iets met input in detail die naam veranderd en doorloopt naar de list
https://angular.io/docs/ts/latest/guide/user-input.html

oefening component lifecycle hooks:
- ngoninit, ngchange (ook dynamic forms), ngondestroy, er zijn nog veel meer
https://angular-2-training-book.rangle.io/handout/advanced-components/component_lifecycle.html

oefening ...:
- forms

oefening ...:
- dynamic forms



oefening ...:
- testing

oefening :

aot voor productie (extra?)






